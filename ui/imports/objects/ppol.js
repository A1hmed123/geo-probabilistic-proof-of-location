// Generated by CoffeeScript 2.2.0
var Web3, web3;

Web3 = require('web3');

web3 = window.web3;

if (typeof web3 !== "undefined") {
  web3 = new Web3(web3.currentProvider);
} else {
  web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
}

export var PPoL = function() {
  var self;
  self = this;
  self.contract = null;
  self.address = null;
  self.init = function(_address) {
    var abi;
    self.address = _address;
    abi = require("./abi/PPoL.json").abi;
    self.contract = new web3.eth.Contract(abi, _address);
    return web3.eth.getAccounts().then(function(accounts) {
      return web3.eth.defaultAccount = accounts[0];
    });
  };
  //Verifying node methods
  self.getVerifyingNodes = function(_name) {
    var array;
    array = [];
    return self.contract.methods["verifyingNodesCount"]().call().then(function(_count) {
      var count, getAllItems, getItem, id;
      count = +_count;
      if (count === 0) {
        return [];
      }
      array = new Array(count);
      getItem = function(id) {
        return self.contract.methods["verifyingNodes"](id).call().then(function(_item) {
          return new Promise(function(fullfill, reject) {
            if (typeof _item !== null) {
              array[id] = _item;
              fullfill();
            } else {
              reject();
            }
          });
        });
      };
      getAllItems = (function() {
        var j, ref, results;
        results = [];
        for (id = j = 0, ref = count - 1; undefined !== 0 && (0 <= ref ? 0 <= j && j <= ref : 0 >= j && j >= ref); id = 0 <= ref ? ++j : --j) {
          results.push(getItem(id));
        }
        return results;
      })();
      return Promise.all(getAllItems);
    }).then(function() {
      return array.filter(function(_addr) {
        return _addr !== "";
      });
    });
  };
  self.getRandomNodes = function(_nodes, _num, _exclude) {
    var cp, id, result;
    cp = _nodes.slice();
    result = [];
    while (_num > 0) {
      id = Math.floor(Math.random() * cp.length);
      result.push(cp[id]);
      cp.remove(id);
      _num -= 1;
    }
    return result;
  };
  self.ringSign = function(_userSig, _prvKey, _dummyNodes) {
    var i, j, randNums, ref;
    randNums = [];
    for (i = j = 0, ref = _dummyNodes.length - 1; undefined !== 0 && (0 <= ref ? 0 <= j && j <= ref : 0 >= j && j >= ref); i = 0 <= ref ? ++j : --j) {
      randNums.push(Math.floor(Math.random() * Math.pow(2, 256)));
    }
    return self.contract.methods.ringSign(_userSig, _prvKey, _dummyNodes, randNums).call().then(function(_sig, _success) {
      var sigJSON;
      if (_success) {
        sigJSON = JSON.stringify(_sig);
        return sigJSON;
      }
      return null;
    });
  };
  //User methods
  self.signUserMsg = function(_uid) {
    var block;
    block = null;
    return web3.eth.getBlock("latest").then(function(_block) {
      var _userSig, msg;
      msg = `${_block.number}${_block.hash}${_uid}`;
      block = _block;
      return _userSig = web3.eth.sign(web3.utils.keccak256(msg), web3.eth.defaultAccount);
    }).then(function(_userSig) {
      var result;
      result = {
        _blockNum: block.number,
        _blockHash: block.hash,
        _uid: _uid,
        _userAddr: web3.eth.defaultAccount,
        _userSig: _userSig
      };
      return result;
    });
  };
  self.logProof = function(_blockNum, _blockHash, _uid, _userAddr, _userSig, _ringSigJSON) {
    return self.contract.methods.logProof(_blockNum, _blockHash, _uid, _userAddr, _userSig, JSON.parse(_ringSigJSON)).send({
      from: web3.eth.defaultAccount
    });
  };
  self.verifyProof = function(_blockNum, _blockHash, _uid, _userAddr, _userSig, _ringSigJSON) {
    return self.contract.methods.verifyProof(_blockNum, _blockHash, _uid, _userAddr, _userSig, JSON.parse(_ringSigJSON)).call();
  };
  return self;
};

//# sourceMappingURL=ppol.js.map
